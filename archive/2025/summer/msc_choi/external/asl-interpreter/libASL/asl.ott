%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ASL grammar description
%
% Copyright Arm Limited (c) 2017-2019
% SPDX-Licence-Identifier: BSD-3-Clause
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

metavar id        ::= {{ ocaml string }} {{ ocamllex ['a'-'z' 'A'-'Z' '_'] ['a'-'z' 'A'-'Z' '0'-'9' '_']*  }}
metavar typeid    ::= {{ ocaml string }} {{ ocamllex ['a'-'z' 'A'-'Z' '_'] ['a'-'z' 'A'-'Z' '0'-'9' '_']*  }}
metavar qualifier ::= {{ phantom }} {{ ocaml string }} {{ ocamllex-remove }} %{{ ocamllex ['a'-'z' 'A'-'Z' '_'] ['a'-'z' 'A'-'Z' '0'-'9' '_']*  }}
metavar intLit    ::= {{ ocaml string }}  {{ ocamllex ['0'-'9']+  }}
metavar bitsLit   ::= {{ ocaml string }}  {{ ocamllex '\'' ['0' '1'     ' ']* '\''  }}
metavar maskLit   ::= {{ ocaml string }}  {{ ocamllex '\'' ['0' '1' 'x' ' ']* '\''  }}
metavar realLit   ::= {{ ocaml string }}  {{ ocamllex ['0'-'9']+ '.' ['0'-'9']+ }}
metavar hexLit    ::= {{ ocaml string }}  {{ ocamllex '0''x'['0'-'9' 'A' - 'F' 'a'-'f' '_']+  }}
metavar stringLit ::= {{ ocaml string }}  {{ ocamllex '"' [^'"']* '"'  }} {{ phantom }}

indexvar i, m, n ::= {{ ocaml int }}

% The following is the OCaml type of source locations.
embed
{{ ocaml

(** Location tracking *)
type l =
    | Unknown
    | Int of string * l option
    | Generated of l
    | Range of Lexing.position * Lexing.position

type 'a annot = l * 'a

let pp_lexing_position (p: Lexing.position): string =
    Printf.sprintf  "file \"%s\" line %d char %d"
        p.Lexing.pos_fname p.Lexing.pos_lnum (p.Lexing.pos_cnum - p.Lexing.pos_bol)

let rec pp_loc (l: l): string =  match l with
    | Unknown -> "no location information available"
    | Generated l -> Printf.sprintf "Generated: %s"  (pp_loc l)
    | Range(p1, p2) ->
        if String.equal p1.Lexing.pos_fname p2.Lexing.pos_fname then begin
            if p1.Lexing.pos_lnum = p2.Lexing.pos_lnum then
                Printf.sprintf "file \"%s\" line %d char %d - %d"
                    p1.Lexing.pos_fname
                    p1.Lexing.pos_lnum
                    (p1.Lexing.pos_cnum - p1.Lexing.pos_bol)
                    (p2.Lexing.pos_cnum - p2.Lexing.pos_bol)
            else
                Printf.sprintf "file \"%s\" line %d char %d - line %d char %d"
                    p1.Lexing.pos_fname
                    p1.Lexing.pos_lnum
                    (p1.Lexing.pos_cnum - p1.Lexing.pos_bol)
                    p2.Lexing.pos_lnum
                    (p2.Lexing.pos_cnum - p2.Lexing.pos_bol)
        end else begin
            Printf.sprintf "file \"%s\" line %d char %d - file \"%s\" line %d char %d"
                p1.Lexing.pos_fname
                p1.Lexing.pos_lnum
                (p1.Lexing.pos_cnum - p1.Lexing.pos_bol)
                p2.Lexing.pos_fname
                p2.Lexing.pos_lnum
                (p2.Lexing.pos_cnum - p2.Lexing.pos_bol)
        end
    | Int(s,lo) -> Printf.sprintf "%s %s" s (match lo with Some l -> pp_loc l | None -> "none")

(** Parsing exceptions (1/2) *)
exception Parse_error_locn of l * string

(** Identifiers used for variable names, function names, etc.

    There are two kinds of identifier:
    - Ident is generated by the parser - it is just a string
    - FIdent is generated by the disambiguation part of the typechecker and
      includes a unique label to distinguish different entities with
      the same name in the source syntax.
 *)
type ident =
    | Ident of string
    | FIdent of string * int

let pprint_ident (x: ident): string =
    (match x with
    | Ident(s)    -> s
    | FIdent(s,t) -> s ^"."^ string_of_int t
    )

let addTag (x: ident) (tag: int): ident =
    (match x with
    | Ident(s)    -> FIdent (s, tag)
    | FIdent(_,_) -> failwith "addTag"
    )

let stripTag (x: ident): ident =
    (match x with
    | Ident(s)
    | FIdent(s,_) -> Ident (s)
    )

let name_of_FIdent (x: ident): string =
    (match x with
    | Ident(_)    -> failwith "name_of_FIdent"
    | FIdent(s,_) -> s
    )


let addQualifier (p: string) (x: ident): ident =
    (match x with
    | Ident(s)    -> Ident (p ^ "." ^ s)
    | FIdent(_,_) -> failwith "addQualifier"
    )

let addPrefix (p: string) (x: ident): ident =
    (match x with
    | Ident(q)    -> Ident (p ^ "." ^ q)
    | FIdent(_,_) -> failwith "addQualifier"
    )

let addSuffix (x: ident) (s: string): ident =
    (match x with
    | Ident(p)    -> Ident (p ^ "." ^ s)
    | FIdent(_,_) -> failwith "addQualifier"
    )

let genericTyvar (i: int): ident =
    let v = "$" ^ string_of_int i in
    Ident v

let isGenericTyvar (x: ident): bool =
    (match x with
    | Ident(s)    -> s.[0] = '$'
    | FIdent(_,_) -> failwith "addQualifier"
    )

module Id = struct
    type t = ident
    let compare (x: ident) (y: ident): int =
        (match (x, y) with
        | (Ident x, Ident y) ->
            String.compare x y
        | (FIdent (x,i), FIdent (y,j)) ->
            let cx = String.compare x y in
            if cx <> 0 then cx else compare i j
        | (Ident _, FIdent (_, _)) -> -1
        | (FIdent (_, _), Ident _) -> 1
        )
end

(** Type Identifiers *)

module StringSet = Set.Make(String)

let typeIdents = ref StringSet.empty

let addTypeIdent (x: ident): unit = begin
    (* ignore (Printf.printf "New type identifier %s\n" (pprint_ident x)); *)
    typeIdents := StringSet.add (pprint_ident x) !typeIdents
end

let isTypeIdent (x: string): bool = StringSet.mem x !typeIdents

}}

grammar
l :: '' ::=            {{ phantom }}
                       {{ ocaml l }}
                       {{ com Source location }}
                       {{ pp     l = pp_loc l }}
                       {{ pp-raw l = PPrint.string (pp_loc l) }}
  |                    :: :: Unknown {{ ocaml Unknown }}

ident :: '' ::=        {{ phantom }}
                       {{ ocaml ident }}
                       {{ com Identifier }}
                       {{ pp     l = PPrint.string (pprint_ident l) }}
                       {{ pp-raw l = PPrint.string (pprint_ident l) }}
  | id                 :: :: Ident {{ ocaml Ident [[id]] }}

typeident :: '' ::=    {{ phantom }}
                       {{ ocaml ident }}
                       {{ com Type Identifier }}
                       {{ pp     l = PPrint.string (pprint_ident l) }}
                       {{ pp-raw l = PPrint.string (pprint_ident l) }}
  | typeid             :: :: TypeIdent {{ ocaml Ident [[typeid]] }}

grammar

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Declarations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

leadingblank :: 'Leading' ::=
    | EOL :: :: Blank
    |     :: :: Nothing

declarations :: 'Decls_' ::= {{ menhir-start }}
    {{ phantom }} {{ ocaml declaration list }}
    {{ pp-raw es = string "[ "^^ separate (string ";\n") (List.map pp_raw_declaration es) ^^ string " ]" }}
    % {{ pp es = separate (string "\n") (List.map pp_declaration es) }}
    {{ pp es = string "{\"node_type\":\"Decls\",\"node_subtype\":\"Decls\",\"node_data\":{\"serde_tag\":\"Decls\",\"decls\":["
        ^^ separate (string ",") (List.map pp_declaration es)
        ^^ string "]}"
        ^^ string "}" }}
    | leadingblank declaration1 .. declarationn :: :: Decls
                                          {{ ocaml [[declaration1..declarationn]] }}

declaration :: 'Decl_' ::=
    {{ aux _ l }}
    {{ pp es = match es with
        | Decl_BuiltinType (identifier, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"BuiltinType\",\"node_data\":{\"serde_tag\":\"DeclBuiltinType\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_Forward (identifier, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"Forward\",\"node_data\":{\"serde_tag\":\"DeclForward\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_Record (identifier, fields, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"Record\",\"node_data\":{\"serde_tag\":\"DeclRecord\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"fields\":["
            ^^ PPrint.separate_map (PPrint.string ",") 
                (fun (ty, ident) -> 
                    PPrint.string "{\"ty\":"
                    ^^ pp_ty ty
                    ^^ PPrint.string ",\"ident\":\""
                    ^^ pp_ident ident
                    ^^ PPrint.string "\"}") 
                fields
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_Typedef (identifier, typ, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"Typedef\",\"node_data\":{\"serde_tag\":\"DeclTypedef\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"ty\":"
            ^^ pp_ty typ
            ^^ string ",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_Enum (identifier, identifiers, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"Enum\",\"node_data\":{\"serde_tag\":\"DeclEnum\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"idents\":["
            ^^ separate (string ",") (List.map (fun ident -> string "\"" ^^ pp_ident ident ^^ string "\"") identifiers)
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_Var (typ, identifier, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"Var\",\"node_data\":{\"serde_tag\":\"DeclVar\",\"ty\":"
            ^^ pp_ty typ
            ^^ string ",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_Const (typ, identifier, expression, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"Const\",\"node_data\":{\"serde_tag\":\"DeclConst\",\"ty\":"
            ^^ pp_ty typ
            ^^ string ",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"expr\":"
            ^^ pp_expr expression
            ^^ string ",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_BuiltinFunction (typ, identifier, parameters, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"BuiltinFunction\",\"node_data\":{\"serde_tag\":\"DeclBuiltinFunction\",\"ty\":"
            ^^ pp_ty typ
            ^^ string ",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"params\":["
            ^^ PPrint.separate_map (PPrint.string ",") 
                (fun (ty, ident) -> 
                    PPrint.string "{\"ty\":"
                    ^^ pp_ty ty
                    ^^ PPrint.string ",\"ident\":\""
                    ^^ pp_ident ident
                    ^^ PPrint.string "\"}") 
                parameters
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_FunType (typ, identifier, parameters, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"FunType\",\"node_data\":{\"serde_tag\":\"DeclFunType\",\"ty\":"
            ^^ pp_ty typ
            ^^ string ",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"params\":["
            ^^ PPrint.separate_map (PPrint.string ",") 
                (fun (ty, ident) -> 
                    PPrint.string "{\"ty\":"
                    ^^ pp_ty ty
                    ^^ PPrint.string ",\"ident\":\""
                    ^^ pp_ident ident
                    ^^ PPrint.string "\"}") 
                parameters
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_FunDefn (typ, identifier, parameters, statements, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"FunDefn\",\"node_data\":{\"serde_tag\":\"DeclFunDefn\",\"ty\":"
            ^^ pp_ty typ
            ^^ string ",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"params\":["
            ^^ PPrint.separate_map (PPrint.string ",") 
                (fun (ty, ident) -> 
                    PPrint.string "{\"ty\":"
                    ^^ pp_ty ty
                    ^^ PPrint.string ",\"ident\":\""
                    ^^ pp_ident ident
                    ^^ PPrint.string "\"}") 
                parameters
            ^^ string "],\"stmts\":["
            ^^ separate (string ",") (List.map (fun stmt -> pp_stmt stmt) statements)
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_ProcType (identifier, parameters, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"ProcType\",\"node_data\":{\"serde_tag\":\"DeclProcType\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"params\":["
            ^^ PPrint.separate_map (PPrint.string ",") 
                (fun (ty, ident) -> 
                    PPrint.string "{\"ty\":"
                    ^^ pp_ty ty
                    ^^ PPrint.string ",\"ident\":\""
                    ^^ pp_ident ident
                    ^^ PPrint.string "\"}") 
                parameters
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_ProcDefn (identifier, parameters, statements, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"ProcDefn\",\"node_data\":{\"serde_tag\":\"DeclProcDefn\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"params\":["
            ^^ PPrint.separate_map (PPrint.string ",") 
                (fun (ty, ident) -> 
                    PPrint.string "{\"ty\":"
                    ^^ pp_ty ty
                    ^^ PPrint.string ",\"ident\":\""
                    ^^ pp_ident ident
                    ^^ PPrint.string "\"}") 
                parameters
            ^^ string "],\"stmts\":["
            ^^ separate (string ",") (List.map (fun stmt -> pp_stmt stmt) statements)
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_VarGetterType (typ, identifier, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"VarGetterType\",\"node_data\":{\"serde_tag\":\"DeclVarGetterType\",\"ty\":"
            ^^ pp_ty typ
            ^^ string ",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_VarGetterDefn (typ, identifier, statements, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"VarGetterDefn\",\"node_data\":{\"serde_tag\":\"DeclVarGetterDefn\",\"ty\":"
            ^^ pp_ty typ
            ^^ string ",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"stmts\":["
            ^^ separate (string ",") (List.map (fun stmt -> pp_stmt stmt) statements)
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_ArrayGetterType (typ, identifier, parameters, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"ArrayGetterType\",\"node_data\":{\"serde_tag\":\"DeclArrayGetterType\",\"ty\":"
            ^^ pp_ty typ
            ^^ string ",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"params\":["
            ^^ PPrint.separate_map (PPrint.string ",") 
                (fun (ty, ident) -> 
                    PPrint.string "{\"ty\":"
                    ^^ pp_ty ty
                    ^^ PPrint.string ",\"ident\":\""
                    ^^ pp_ident ident
                    ^^ PPrint.string "\"}") 
                parameters
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_ArrayGetterDefn (typ, identifier, parameters, statements, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"ArrayGetterDefn\",\"node_data\":{\"serde_tag\":\"DeclArrayGetterDefn\",\"ty\":"
            ^^ pp_ty typ
            ^^ string ",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"params\":["
            ^^ PPrint.separate_map (PPrint.string ",") 
                (fun (ty, ident) -> 
                    PPrint.string "{\"ty\":"
                    ^^ pp_ty ty
                    ^^ PPrint.string ",\"ident\":\""
                    ^^ pp_ident ident
                    ^^ PPrint.string "\"}") 
                parameters
            ^^ string "],\"stmts\":["
            ^^ separate (string ",") (List.map (fun stmt -> pp_stmt stmt) statements)
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_VarSetterType (identifier1, typ, identifier2, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"VarSetterType\",\"node_data\":{\"serde_tag\":\"DeclVarSetterType\",\"ident1\":\""
            ^^ pp_ident identifier1
            ^^ string "\",\"ty\":"
            ^^ pp_ty typ
            ^^ string ",\"ident2\":\""
            ^^ pp_ident identifier2
            ^^ string "\",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_VarSetterDefn (identifier1, typ, identifier2, statements, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"VarSetterDefn\",\"node_data\":{\"serde_tag\":\"DeclVarSetterDefn\",\"ident1\":\""
            ^^ pp_ident identifier1
            ^^ string "\",\"ty\":"
            ^^ pp_ty typ
            ^^ string ",\"ident2\":\""
            ^^ pp_ident identifier2
            ^^ string "\",\"stmts\":["
            ^^ separate (string ",") (List.map (fun stmt -> pp_stmt stmt) statements)
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_ArraySetterType (identifier1, parameters, typ, identifier2, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"ArraySetterType\",\"node_data\":{\"serde_tag\":\"DeclArraySetterType\",\"ident1\":\""
            ^^ pp_ident identifier1
            ^^ string "\",\"params\":["
            ^^ separate (string ",") (List.map (fun parameter -> pp_sformal parameter) parameters)
            ^^ string "],\"ty\":"
            ^^ pp_ty typ
            ^^ string ",\"ident2\":\""
            ^^ pp_ident identifier2
            ^^ string "\",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_ArraySetterDefn (identifier1, parameters, typ, identifier2, statements, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"ArraySetterDefn\",\"node_data\":{\"serde_tag\":\"DeclArraySetterDefn\",\"ident1\":\""
            ^^ pp_ident identifier1
            ^^ string "\",\"params\":["
            ^^ separate (string ",") (List.map (fun parameter -> pp_sformal parameter) parameters)
            ^^ string "],\"ty\":"
            ^^ pp_ty typ
            ^^ string ",\"ident2\":\""
            ^^ pp_ident identifier2
            ^^ string "\",\"stmts\":["
            ^^ separate (string ",") (List.map (fun stmt -> pp_stmt stmt) statements)
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_InstructionDefn (identifier, encodings, opt_statements, boolean, statements, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"InstructionDefn\",\"node_data\":{\"serde_tag\":\"DeclInstructionDefn\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"encodings\":["
            ^^ separate (string ",") (List.map pp_encoding encodings)
            ^^ string "],\"opt_stmts\":"
            ^^ (match opt_statements with
                | Some stmts -> string "[" ^^ separate (string ",") (List.map pp_stmt stmts) ^^ string "]"
                | None -> string "null")
            ^^ string ",\"bool\":"
            ^^ PPrint.string (if boolean then "true" else "false")
            ^^ string ",\"stmts\":["
            ^^ separate (string ",") (List.map pp_stmt statements)
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_DecoderDefn (identifier, decode_case, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"DecoderDefn\",\"node_data\":{\"serde_tag\":\"DeclDecoderDefn\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"decode_case\":"
            ^^ pp_decode_case decode_case
            ^^ string ",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_Operator1 (unary_operator, identifiers, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"Operator1\",\"node_data\":{\"serde_tag\":\"DeclOperator1\",\"unop\":"
            ^^ pp_unop unary_operator
            ^^ string ",\"idents\":["
            ^^ separate (string ",") (List.map (fun ident -> string "\"" ^^ pp_ident ident ^^ string "\"") identifiers)
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_Operator2 (binary_operator, identifiers, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"Operator2\",\"node_data\":{\"serde_tag\":\"DeclOperator2\",\"binop\":"
            ^^ pp_binop binary_operator
            ^^ string ",\"idents\":["
            ^^ separate (string ",") (List.map (fun ident -> string "\"" ^^ pp_ident ident ^^ string "\"") identifiers)
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_NewEventDefn (identifier, parameters, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"NewEventDefn\",\"node_data\":{\"serde_tag\":\"DeclNewEventDefn\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"params\":["
            ^^ PPrint.separate_map (PPrint.string ",") 
                (fun (ty, ident) -> 
                    PPrint.string "{\"ty\":"
                    ^^ pp_ty ty
                    ^^ PPrint.string ",\"ident\":\""
                    ^^ pp_ident ident
                    ^^ PPrint.string "\"}") 
                parameters
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_EventClause (identifier, statements, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"EventClause\",\"node_data\":{\"serde_tag\":\"DeclEventClause\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"stmts\":["
            ^^ separate (string ",") (List.map (fun stmt -> pp_stmt stmt) statements)
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_NewMapDefn (typ, identifier, parameters, statements, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"NewMapDefn\",\"node_data\":{\"serde_tag\":\"DeclNewMapDefn\",\"ty\":"
            ^^ pp_ty typ
            ^^ string ",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"params\":["
            ^^ PPrint.separate_map (PPrint.string ",") 
                (fun (ty, ident) -> 
                    PPrint.string "{\"ty\":"
                    ^^ pp_ty ty
                    ^^ PPrint.string ",\"ident\":\""
                    ^^ pp_ident ident
                    ^^ PPrint.string "\"}") 
                parameters
            ^^ string "],\"stmts\":["
            ^^ separate (string ",") (List.map (fun stmt -> pp_stmt stmt) statements)
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_MapClause (identifier, mapfields, opt_expression, statements, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"MapClause\",\"node_data\":{\"serde_tag\":\"DeclMapClause\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"mapfields\":["
            ^^ separate (string ",") (List.map (fun mapfield -> pp_mapfield mapfield) mapfields)
            ^^ string "],\"opt_expr\":"
            ^^ (match opt_expression with
                | Some expr -> pp_expr expr
                | None -> string "null")
            ^^ string ",\"stmts\":["
            ^^ separate (string ",") (List.map (fun stmt -> pp_stmt stmt) statements)
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Decl_Config (typ, identifier, expression, location) -> string "{\"node_type\":\"Decl\",\"node_subtype\":\"Config\",\"node_data\":{\"serde_tag\":\"DeclConfig\",\"ty\":"
            ^^ pp_ty typ
            ^^ string ",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"expr\":"
            ^^ pp_expr expression
            ^^ string ",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}" }}
    | type_declaration          :: :: TDecl {{ quotient-remove }} {{ ocaml [[type_declaration]] }}
    | variable_declaration      :: :: VDecl {{ quotient-remove }} {{ ocaml [[variable_declaration]] }}
    | function_declaration      :: :: FDecl {{ quotient-remove }} {{ ocaml [[function_declaration]] }}
    | procedure_declaration     :: :: PDecl {{ quotient-remove }} {{ ocaml [[procedure_declaration]] }}
    | getter_declaration        :: :: GDecl {{ quotient-remove }} {{ ocaml [[getter_declaration]] }}
    | setter_declaration        :: :: SDecl {{ quotient-remove }} {{ ocaml [[setter_declaration]] }}
    | instruction_definition    :: :: IDecl {{ quotient-remove }} {{ ocaml [[instruction_definition]] }}
    | internal_definition       :: :: ADecl {{ quotient-remove }} {{ ocaml [[internal_definition]] }}

type_declaration :: 'Decl_' ::= {{ quotient-with declaration }}
    {{ aux _ l }}
    | __builtin type tidentdecl ; EOL                          ::   :: BuiltinType
    | type tidentdecl ; EOL                                    ::   :: Forward % says there is a type decl elsewhere
    | record tidentdecl { field1 ... fieldn } ; EOL            ::   :: Record
    | type tidentdecl is ( field_ns1 , ... , field_nsn ) EOL   :: S :: Dep_Record {{ ocaml Decl_Record([[tidentdecl]], [[field_ns1 ... field_nsn]], Range($symbolstartpos,$endpos)) }} {{ com DEPRECATED }}
    | type tidentdecl = ty ; EOL                               ::   :: Typedef
    | enumeration tidentdecl { ident1 , .. , identn } ; EOL    ::   :: Enum

field_ns :: 'FieldNS_' ::=
    {{ phantom }} {{ ocaml ty * ident }}
    {{ pp-raw f = string "(" ^^ pp_raw_ty (fst f) ^^ string ", " ^^ string (snd f) ^^ string ")" }}
    {{ pp f     = pp_ty (fst f) ^^ string " " ^^ string (snd f) }}
    | ty ident              :: :: Field {{ ocaml ([[ty]], [[ident]]) }}

field :: 'Field_' ::=
    {{ phantom }} {{ ocaml ty * ident }}
    {{ pp-raw f = string "(" ^^ pp_raw_ty (fst f) ^^ string ", " ^^ pp_raw_ident (snd f) ^^ string ")" }}
    {{ pp f     = pp_ty (fst f) ^^ string " " ^^ pp_ident (snd f) }}
    | ty ident ;            :: :: Field {{ ocaml ([[ty]], [[ident]]) }}

variable_declaration :: 'Decl_' ::= {{ quotient-with declaration }}
    {{ aux _ l }}
    | ty qualident ; EOL                                       ::   :: Var
    | constant ty qualident = expr ; EOL                       ::   :: Const
    | array ty qualident [ ixtype ] ; EOL                      :: S :: Array {{ ocaml Decl_Var(Type_Array([[ixtype]],[[ty]]), [[qualident]], Range($symbolstartpos,$endpos)) }}

ixtype :: 'Index_' ::=
    {{ pp es = match es with
        | Index_Enum identifier -> string "{\"node_type\":\"Index\",\"node_subtype\":\"Enum\",\"node_data\":{\"serde_tag\":\"IndexEnum\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\"}"
            ^^ string "}"
        | Index_Range (expression1, expression2) -> string "{\"node_type\":\"Index\",\"node_subtype\":\"Range\",\"node_data\":{\"serde_tag\":\"IndexRange\",\"expr1\":"
            ^^ pp_expr expression1
            ^^ string ",\"expr2\":"
            ^^ pp_expr expression2
            ^^ string "}"
            ^^ string "}" }}
    | tident                        :: :: Enum
    | expr1 '..' expr2              :: :: Range

function_declaration :: 'Decl_' ::= {{ quotient-with declaration }}
    {{ aux _ l }}
    | __builtin ty qualident ( formal1 , .. , formaln ) ; EOL      :: :: BuiltinFunction
    | ty qualident ( formal1 , .. , formaln ) ; EOL                :: :: FunType
    | ty qualident ( formal1 , .. , formaln ) opt_indented_block   :: :: FunDefn

procedure_declaration :: 'Decl_' ::= {{ quotient-with declaration }}
    {{ aux _ l }}
    | qualident ( formal1 , .. , formaln ) ; EOL                   :: :: ProcType
    | qualident ( formal1 , .. , formaln ) opt_indented_block      :: :: ProcDefn

formal :: 'Formal_' ::=
    {{ phantom }} {{ ocaml ty * ident }}
    {{ pp-raw f = string "(" ^^ pp_raw_ty (fst f) ^^ string ", " ^^ pp_raw_ident (snd f) ^^ string ")" }}
    {{ pp f     = pp_ty (fst f) ^^ string " " ^^ pp_ident (snd f) }}
    | ty ident              :: :: In2 {{ ocaml ([[ty]], [[ident]]) }}

getter_declaration :: 'Decl_' ::= {{ quotient-with declaration }}
    {{ aux _ l }}
    % Note: VarGetterType is an unofficial extension because ASL has no official way
    % to declare a getter because syntax would be same as declaring a variable
    | __function ty qualident ; EOL                                        :: :: VarGetterType
    | ty qualident opt_indented_block                                      :: :: VarGetterDefn
    | ty qualident [ formal1 , .. , formaln ] ; EOL                        :: :: ArrayGetterType
    | ty qualident [ formal1 , .. , formaln ] opt_indented_block           :: :: ArrayGetterDefn

setter_declaration :: 'Decl_' ::= {{ quotient-with declaration }}
    {{ aux _ l }}
    | qualident = ty ident ; EOL                                           :: :: VarSetterType
    | qualident = ty ident opt_indented_block                              :: :: VarSetterDefn
    | qualident [ sformal1 , .. , sformaln ] = ty ident ; EOL              :: :: ArraySetterType
    | qualident [ sformal1 , .. , sformaln ] = ty ident opt_indented_block :: :: ArraySetterDefn

sformal :: 'Formal_' ::=
    {{ pp es = match es with
        | Formal_In (typ, identifier) -> string "{\"node_type\":\"Formal\",\"node_subtype\":\"In\",\"node_data\":{\"serde_tag\":\"FormalIn\",\"ty\":"
            ^^ pp_ty typ
            ^^ string ",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\"}"
            ^^ string "}"
        | Formal_InOut (typ, identifier) -> string "{\"node_type\":\"Formal\",\"node_subtype\":\"InOut\",\"node_data\":{\"serde_tag\":\"FormalInOut\",\"ty\":"
            ^^ pp_ty typ
            ^^ string ",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\"}"
            ^^ string "}" }}
    | ty ident              :: :: In
    | ty & ident            :: :: InOut

instruction_definition :: 'Decl_' ::= {{ quotient-with declaration }}
    {{ aux _ l }}
    | __instruction ident EOL INDENT
          encoding1 ... encodingn
          opt_postdecode
          __execute opt_conditional opt_indented_block
      DEDENT
      :: :: InstructionDefn
    | __decode ident EOL INDENT
          decode_case
      DEDENT
      :: :: DecoderDefn

encoding :: 'Encoding_' ::=
    {{ aux _ l }}
    {{ pp es = match es with
        | Encoding_Block (identifier1, identifier2, instruction_fields, opcode_value, expression, unpredictables, statements, location) -> string "{\"node_type\":\"Encoding\",\"node_subtype\":\"Block\",\"node_data\":{\"serde_tag\":\"EncodingBlock\",\"ident1\":\""
            ^^ pp_ident identifier1
            ^^ string "\",\"ident2\":\""
            ^^ pp_ident identifier2
            ^^ string "\",\"instr_fields\":["
            ^^ separate (string ",") (List.map pp_instr_field instruction_fields)
            ^^ string "],\"opcode_value\":"
            ^^ pp_opcode_value opcode_value
            ^^ string ",\"expr\":"
            ^^ pp_expr expression
            ^^ string ",\"unpredictables\":["
            ^^ separate (string ",")
                (List.map (fun (int, bitsList) ->
                    string "{\"int\":"
                        ^^ PPrint.string (string_of_int int)
                        ^^ string ",\"bits_list\":\""
                        ^^ string bitsList
                        ^^ string "\"}")
                    unpredictables)
            ^^ string "],\"stmts\":["
            ^^ separate (string ",") (List.map pp_stmt statements)
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}" }}
    | __encoding ident1 EOL INDENT
          __instruction_set ident2 EOL
          instr_field1 .. instr_fieldm
          __opcode opcode_value EOL
          __guard expr EOL
          instr_unpred1 .. instr_unpredn
          __decode opt_indented_block
      DEDENT
      :: :: Block

opt_conditional :: 'OptConditional_' ::=
    {{ phantom }} {{ ocaml bool }}
    {{ pp-raw x = if x then string "__conditional" else string "" }}
    {{ pp     x = if x then string "__conditional" else string "" }}
    | __conditional :: :: True  {{ ocaml true  }}
    |               :: :: False {{ ocaml false }}

opt_postdecode :: 'OptPostDecode_' ::=
    {{ phantom }} {{ ocaml (stmt list) option }}
    {{ pp-raw x = match x with Some(ys) -> string "Some(" ^^ separate (string "\n") (List.map pp_raw_stmt ys) ^^ string ")" | None -> string "None" }}
    {{ pp     x = match x with Some(ys) -> string "postdecode" ^^ hardline
                                           ^^ (nest 4 (separate (string "\n") (List.map pp_stmt ys)))
                             | None -> string "" }}
    | __postdecode indented_block   :: :: Some {{ ocaml Some([[indented_block]]) }}
    |                               :: :: None {{ ocaml None }}

instr_field :: 'IField_' ::=
    {{ pp es = match es with
        | IField_Field (identifier, int1, int2) -> string "{\"node_type\":\"IField\",\"node_subtype\":\"Field\",\"node_data\":{\"serde_tag\":\"IField\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"int1\":"
            ^^ PPrint.string (string_of_int int1)
            ^^ string ",\"int2\":"
            ^^ PPrint.string (string_of_int int2)
            ^^ string "}"
            ^^ string "}" }}
    | __field ident offset1 +: offset2 EOL :: :: Field

% OTT workaround: I can't write "intlit1 : intLit2" in a rule
% because intLit is a terminal not a non-terminal
offset :: 'Offset_' ::=
    {{ phantom }} {{ ocaml int }}
    {{ pp-raw x = string "??" }}
    {{ pp     x = string "??" }}
    | intLit :: :: Int {{ ocaml int_of_string [[intLit]] }}

opcode_value :: 'Opcode_' ::=
    {{ pp es = match es with
        | Opcode_Bits bits -> string "{\"node_type\":\"Opcode\",\"node_subtype\":\"Bits\",\"node_data\":{\"serde_tag\":\"OpcodeBits\",\"bits_lit\":\""
            ^^ string bits
            ^^ string "\"}"
            ^^ string "}"
        | Opcode_Mask mask -> string "{\"node_type\":\"Opcode\",\"node_subtype\":\"Mask\",\"node_data\":{\"serde_tag\":\"OpcodeMask\",\"bits_lit\":\""
            ^^ string mask
            ^^ string "\"}"
            ^^ string "}" }}
    | bitsLit :: :: Bits
    | maskLit :: :: Mask

instr_unpred :: 'Instr_Unpred_' ::=
    {{ phantom }} {{ ocaml (int * bitsLit) }}
    {{ pp-raw x = string "??" }}
    {{ pp     x = string "??" }}
    | __unpredictable_unless intLit == bitsLit EOL :: :: Unpred {{ ocaml (int_of_string [[intLit]], [[bitsLit]]) }}

decode_case :: 'DecoderCase_' ::=
    {{ aux _ l }}
    {{ pp es = match es with
        | DecoderCase_Case (decode_slices, decode_alts, location) -> string "{\"node_type\":\"DecoderCase\",\"node_subtype\":\"Case\",\"node_data\":{\"serde_tag\":\"DecoderCase\",\"decode_slices\":["
            ^^ separate (string ",") (List.map pp_decode_slice decode_slices)
            ^^ string "],\"decode_alts\":["
            ^^ separate (string ",") (List.map pp_decode_alt decode_alts)
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}" }}
    | case ( decode_slice1 , .. , decode_slicem ) of EOL
      INDENT
          decode_alt1 ... decode_altn
      DEDENT
      :: :: Case

decode_slice :: 'DecoderSlice_' ::=
    {{ pp es = match es with 
        | DecoderSlice_Slice (int1, int2) -> string "{\"node_type\":\"DecoderSlice\",\"node_subtype\":\"Slice\",\"node_data\":{\"serde_tag\":\"DecoderSlice\",\"int1\":"
            ^^ PPrint.string (string_of_int int1)
            ^^ string ",\"int2\":"
            ^^ PPrint.string (string_of_int int2)
            ^^ string "}"
            ^^ string "}"
        | DecoderSlice_FieldName (identifier) -> string "{\"node_type\":\"DecoderSlice\",\"node_subtype\":\"FieldName\",\"node_data\":{\"serde_tag\":\"DecoderSliceFieldName\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\"}"
            ^^ string "}"
        | DecoderSlice_Concat (identifiers) -> string "{\"node_type\":\"DecoderSlice\",\"node_subtype\":\"Concat\",\"node_data\":{\"serde_tag\":\"DecoderSliceConcat\",\"idents\":["
            ^^ separate (string ",") (List.map (fun ident -> string "\"" ^^ pp_ident ident ^^ string "\"") identifiers)
            ^^ string "]}"
            ^^ string "}" }}
    | offset1 +: offset2     :: :: Slice
    | ident                  :: :: FieldName
    | ident1 : .... : identn :: :: Concat

decode_alt :: 'DecoderAlt_' ::=
    {{ pp es = match es with 
        | DecoderAlt_Alt (decode_patterns, decode_body) -> string "{\"node_type\":\"DecoderAlt\",\"node_subtype\":\"Alt\",\"node_data\":{\"serde_tag\":\"DecoderAlt\",\"decode_patterns\":["
            ^^ separate (string ",") (List.map pp_decode_pattern decode_patterns)
            ^^ string "],\"decode_body\":"
            ^^ pp_decode_body decode_body
            ^^ string "}"
            ^^ string "}" }}
    | when ( decode_pattern1 , .. , decode_patternm ) => decode_body :: :: Alt

decode_pattern :: 'DecoderPattern_' ::=
    {{ pp es = match es with
        | DecoderPattern_Bits (bitsLiteral) -> string "{\"node_type\":\"DecoderPattern\",\"node_subtype\":\"Bits\",\"node_data\":{\"serde_tag\":\"DecoderPatternBits\",\"bits_lit\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String bitsLiteral))
            ^^ string "}"
            ^^ string "}"
        | DecoderPattern_Mask (maskLiteral) -> string "{\"node_type\":\"DecoderPattern\",\"node_subtype\":\"Mask\",\"node_data\":{\"serde_tag\":\"DecoderPatternMask\",\"mask_lit\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String maskLiteral))
            ^^ string "}"
            ^^ string "}"
        | DecoderPattern_Wildcard (identifier) -> string "{\"node_type\":\"DecoderPattern\",\"node_subtype\":\"Wildcard\",\"node_data\":{\"serde_tag\":\"DecoderPatternWildcard\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\"}"
            ^^ string "}"
        | DecoderPattern_Not (decode_pattern) -> string "{\"node_type\":\"DecoderPattern\",\"node_subtype\":\"Not\",\"node_data\":{\"serde_tag\":\"DecoderPatternNot\",\"decode_pattern\":"
            ^^ pp_decode_pattern decode_pattern
            ^^ string "}"
            ^^ string "}" }}
    | bitsLit          :: :: Bits
    | maskLit          :: :: Mask
    | ident            :: :: Wildcard {{ com todo: wildcard should be underscore }}
    | ! decode_pattern :: :: Not

decode_body :: 'DecoderBody_' ::=
    {{ aux _ l }}
    {{ pp es = match es with
        | DecoderBody_UNPRED (location) -> string "{\"node_type\":\"DecoderBody\",\"node_subtype\":\"UNPRED\",\"node_data\":{\"serde_tag\":\"DecoderBodyUNPRED\",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | DecoderBody_UNALLOC (location) -> string "{\"node_type\":\"DecoderBody\",\"node_subtype\":\"UNALLOC\",\"node_data\":{\"serde_tag\":\"DecoderBodyUNALLOC\",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | DecoderBody_NOP (location) -> string "{\"node_type\":\"DecoderBody\",\"node_subtype\":\"NOP\",\"node_data\":{\"serde_tag\":\"DecoderBodyNOP\",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | DecoderBody_Encoding (identifier, location) -> string "{\"node_type\":\"Encoding\",\"node_subtype\":\"Encoding\",\"node_data\":{\"serde_tag\":\"DecoderBodyEncoding\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | DecoderBody_Decoder (instruction_fields, decode_case, location) -> string "{\"node_type\":\"DecoderBody\",\"node_subtype\":\"Decoder\",\"node_data\":{\"serde_tag\":\"DecoderBodyDecoder\",\"instr_fields\":["
            ^^ separate (string ",") (List.map pp_instr_field instruction_fields)
            ^^ string "],\"decode_case\":"
            ^^ pp_decode_case decode_case
            ^^ string ",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}" }}
    | __UNPREDICTABLE  EOL :: :: UNPRED
    | __UNALLOCATED    EOL :: :: UNALLOC
    | __NOP            EOL :: :: NOP
    | __encoding ident EOL :: :: Encoding
    | EOL INDENT
          instr_field1 .. instr_fieldm
          decode_case
      DEDENT
      :: :: Decoder

% features not found in published ASL but potentially used in glue code
internal_definition :: 'Decl_' ::= {{ quotient-with declaration }}
    {{ aux _ l }}
    | __operator1 unop            = ident1 , ... , identn ; EOL                       :: :: Operator1
    | __operator2 binop_or_concat = ident1 , ... , identn ; EOL                       :: :: Operator2
    | __newevent qualident ( formal1 , .. , formaln ) ; EOL                           :: :: NewEventDefn
    | __event    qualident possibly_empty_block                                       :: :: EventClause
    | __newmap ty qualident ( formal1 , .. , formaln ) opt_indented_block             :: :: NewMapDefn
    | __map qualident mapfield1 , .. , mapfieldn optmapcond then possibly_empty_block :: :: MapClause
    | __config ty qualident = expr ; EOL                                              :: :: Config

operator :: 'Operator_' ::=
    {{ phantom }} {{ ocaml string }}
    {{ pp-raw x = string x }}
    {{ pp     x = string x }}
    | unop  :: :: Unary  {{ ocaml Utils.to_string (Asl_parser_pp.pp_unop  [[unop]])  }}
    | binop :: :: Binary {{ ocaml Utils.to_string (Asl_parser_pp.pp_binop [[binop]]) }}
    | :     :: :: In     {{ ocaml ":" }}

optmapcond :: 'MapCond_' ::=
    {{ phantom }} {{ ocaml expr option }}
    {{ pp-raw x = match x with Some(y) -> string "Some(" ^^ pp_raw_expr y ^^ string ")" | None -> string "None" }}
    {{ pp     x = match x with Some(y) -> pp_expr y | None -> string "" }}
    | when expr :: :: Some {{ ocaml Some([[expr]]) }}
    |           :: :: None {{ ocaml None }}

mapfield :: 'MapField_' ::=
    {{ pp es = match es with
        | MapField_Field (identifier, pattern) -> string "{\"node_type\":\"MapField\",\"node_subtype\":\"Field\",\"node_data\":{\"serde_tag\":\"MapField\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"pattern\":"
            ^^ string "\"placeholder\""
            ^^ string "}"
            ^^ string "}" }}
    | ident = pattern :: :: Field

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Identifiers
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

qualident :: 'QIdent_' ::=
    {{ phantom }} {{ ocaml ident }}
    {{ pp-raw x = pp_raw_ident x }}
    {{ pp     x = pp_ident     x }}
    | ident             :: :: Plain      {{ ocaml [[ident]] }}
    | qualifier . ident :: :: Decorated  {{ ocaml addQualifier [[qualifier]] [[ident]] }}

tidentdecl :: 'QIdent_' ::= {{ quotient-with qualident }}
    | typeident             :: :: Plain2 {{ quotient-remove }} {{ ocaml [[typeident]] }}
    | ident                 :: :: Plain3 {{ quotient-remove }} {{ ocaml addTypeIdent([[ident]]); [[ident]] }}
    | qualifier . ident     :: :: Decorated2 {{ quotient-remove }} {{ ocaml addTypeIdent([[ident]]); addQualifier [[qualifier]] [[ident]] }}

tident :: 'QIdent_' ::= {{ quotient-with qualident }}
    | typeident             :: :: Plain4 {{ quotient-remove }} {{ ocaml [[typeident]] }}
    | qualifier . typeident :: :: Decorated3 {{ quotient-remove }} {{ ocaml addQualifier [[qualifier]] [[typeident]] }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

ty :: 'Type_' ::=
    {{ pp es = match es with
        | Type_Constructor identifier -> string "{\"node_type\":\"Type\",\"node_subtype\":\"Constructor\",\"node_data\":{\"serde_tag\":\"TypeConstructor\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\"}"
            ^^ string "}"
        | Type_Bits expression -> string "{\"node_type\":\"Type\",\"node_subtype\":\"Bits\",\"node_data\":{\"serde_tag\":\"TypeBits\",\"expr\":"
            ^^ pp_expr expression
            ^^ string "}"
            ^^ string "}"
        | Type_App (identifier, expressions) -> string "{\"node_type\":\"Type\",\"node_subtype\":\"App\",\"node_data\":{\"serde_tag\":\"TypeApp\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"exprs\":["
            ^^ separate (string ",") (List.map (fun expr -> pp_expr expr) expressions)
            ^^ string "]}"
            ^^ string "}"
        | Type_OfExpr expression -> string "{\"node_type\":\"Type\",\"node_subtype\":\"OfExpr\",\"node_data\":{\"serde_tag\":\"TypeOfExpr\",\"expr\":"
            ^^ pp_expr expression
            ^^ string "}"
            ^^ string "}"
        | Type_Register (integerLiteral, fields) -> string "{\"node_type\":\"Type\",\"node_subtype\":\"Register\",\"node_data\":{\"serde_tag\":\"TypeRegister\",\"int_lit\":\""
            ^^ string integerLiteral
            ^^ string "\",\"fields\":["
            ^^ separate (string ",") 
                (List.map 
                    (fun (slices, identifier) -> string "{\"slices\":[" 
                        ^^ separate (string ",") (List.map pp_slice slices)
                        ^^ string "],\"ident\":\""
                        ^^ pp_ident identifier
                        ^^ string "\"}") 
                    fields)
            ^^ string "]}"
            ^^ string "}"
        | Type_Array (indexType, typ) -> string "{\"node_type\":\"Type\",\"node_subtype\":\"Array\",\"node_data\":{\"serde_tag\":\"TypeArray\",\"ix_type\":"
            ^^ pp_ixtype indexType
            ^^ string ",\"ty\":"
            ^^ pp_ty typ
            ^^ string "}"
            ^^ string "}"
        | Type_Tuple typs -> string "{\"node_type\":\"Type\",\"node_subtype\":\"Tuple\",\"node_data\":{\"serde_tag\":\"TypeTuple\",\"tys\":["
            ^^ separate (string ",") (List.map pp_ty typs)
            ^^ string "]}"
            ^^ string "}" }}
    | tident                          :: :: Constructor
    | bits ( expr )                   :: :: Bits
    | tident ( expr1 , ... , exprn )  :: :: App
    | typeof ( expr )                 :: :: OfExpr
    | __register intLit { regfields } :: :: Register
    | array [ ixtype ] of ty          :: :: Array
    % I would prefer not to have a tuple type and restrict it to return types.
    | ( ty1 , .. , tyn )              :: :: Tuple

% possibly empty list of regfields separated by comma, with optional trailing comma
regfields :: 'RegFields' ::=
    {{ phantom }} {{ ocaml (slice list * ident) list }}
    {{ pp-raw rfs = separate (string ",\n") (List.map pp_raw_regfield rfs) }}
    {{ pp     rfs = separate (string ",\n") (List.map pp_regfield     rfs) }}
    | regfield1 .. regfieldn :: :: List         {{ ocaml [[regfield1..regfieldn]] }}
    | regfield , regfields   :: :: CommaSepList {{ ocaml [[regfield]] :: [[regfields]] }}

regfield :: 'RegField_' ::=
    {{ phantom }} {{ ocaml slice list * ident }}
    {{ pp-raw rf = string "([ "^^ separate (string ";\n") (List.map pp_raw_slice (fst rf)) ^^ string " ], " ^^ pp_raw_ident (snd rf) ^^ string ")" }}
    {{ pp rf = separate (string "\n") (List.map pp_slice (fst rf)) ^^ string " " ^^ pp_ident (snd rf) }}
    | slice1 , ... , slicen ident     :: :: Field {{ ocaml ([[slice1...slicen]], [[ident]]) }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Statements
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

stmt :: 'Stmt_' ::=
    {{ aux _ l }}
    {{ pp es = match es with
        | Stmt_VarDeclsNoInit (typ, identifiers, location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"VarDeclsNoInit\",\"node_data\":{\"serde_tag\":\"StmtVarDeclsNoInit\",\"ty\":"
            ^^ pp_ty typ
            ^^ string ",\"idents\":["
            ^^ separate (string ",") (List.map (fun ident -> string "\"" ^^ pp_ident ident ^^ string "\"") identifiers)
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Stmt_VarDecl (typ, identifier, expression, location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"VarDecl\",\"node_data\":{\"serde_tag\":\"StmtVarDecl\",\"ty\":"
            ^^ pp_ty typ
            ^^ string ",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"expr\":"
            ^^ pp_expr expression
            ^^ string ",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Stmt_ConstDecl (typ, identifier, expression, location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"ConstDecl\",\"node_data\":{\"serde_tag\":\"StmtConstDecl\",\"ty\":"
            ^^ pp_ty typ
            ^^ string ",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"expr\":"
            ^^ pp_expr expression
            ^^ string ",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Stmt_Assign (left_expression, expression, location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"Assign\",\"node_data\":{\"serde_tag\":\"StmtAssign\",\"l_expr\":"
            ^^ pp_lexpr left_expression
            ^^ string ",\"expr\":"
            ^^ pp_expr expression
            ^^ string ",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Stmt_FunReturn (expression, location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"FunReturn\",\"node_data\":{\"serde_tag\":\"StmtFunReturn\",\"expr\":"
            ^^ pp_expr expression
            ^^ string ",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Stmt_ProcReturn (location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"ProcReturn\",\"node_data\":{\"serde_tag\":\"StmtProcReturn\",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Stmt_Assert (expression, location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"Assert\",\"node_data\":{\"serde_tag\":\"StmtAssert\",\"expr\":"
            ^^ pp_expr expression
            ^^ string ",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Stmt_Unpred (location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"Unpred\",\"node_data\":{\"serde_tag\":\"StmtUnpred\",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Stmt_ConstrainedUnpred (location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"ConstrainedUnpred\",\"node_data\":{\"serde_tag\":\"StmtConstrainedUnpred\",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Stmt_ImpDef (identifier, location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"ImpDef\",\"node_data\":{\"serde_tag\":\"StmtImpDef\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Stmt_Undefined (location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"Undefined\",\"node_data\":{\"serde_tag\":\"StmtUndefined\",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Stmt_ExceptionTaken (location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"ExceptionTaken\",\"node_data\":{\"serde_tag\":\"StmtExceptionTaken\",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Stmt_Dep_Unpred (location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"DepUnpred\",\"node_data\":{\"serde_tag\":\"StmtDepUnpred\",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Stmt_Dep_ImpDef (stringLiteral, location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"DepImpDef\",\"node_data\":{\"serde_tag\":\"StmtDepImpDef\",\"string_lit\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String stringLiteral))
            ^^ string ",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Stmt_Dep_Undefined (location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"DepUndefined\",\"node_data\":{\"serde_tag\":\"StmtDepUndefined\",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Stmt_See (expression, location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"See\",\"node_data\":{\"serde_tag\":\"StmtSee\",\"expr\":"
            ^^ pp_expr expression
            ^^ string ",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Stmt_Throw (identifier, location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"Throw\",\"node_data\":{\"serde_tag\":\"StmtThrow\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Stmt_DecodeExecute (identifier, expression, location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"DecodeExecute\",\"node_data\":{\"serde_tag\":\"StmtDecodeExecute\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"expr\":"
            ^^ pp_expr expression
            ^^ string ",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Stmt_TCall (identifier, expressions1, expressions2, location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"TCall\",\"node_data\":{\"serde_tag\":\"StmtTCall\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"exprs1\":["
            ^^ separate (string ",") (List.map (fun expr -> pp_expr expr) expressions1)
            ^^ string "],\"exprs2\":["
            ^^ separate (string ",") (List.map (fun expr -> pp_expr expr) expressions2)
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Stmt_If (expression, statements1, s_elsifs, statements2, location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"If\",\"node_data\":{\"serde_tag\":\"StmtIf\",\"expr\":"
            ^^ pp_expr expression
            ^^ string ",\"stmts1\":["
            ^^ separate (string ",") (List.map pp_stmt statements1)
            ^^ string "],\"s_elsifs\":["
            ^^ separate (string ",") (List.map pp_s_elsif s_elsifs)
            ^^ string "],\"stmts2\":["
            ^^ separate (string ",") (List.map pp_stmt statements2)
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Stmt_Case (expression, alternatives, opt_statements, location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"Case\",\"node_data\":{\"serde_tag\":\"StmtCase\",\"expr\":"
            ^^ pp_expr expression
            ^^ string ",\"alts\":["
            ^^ separate (string ",") (List.map pp_alt alternatives)
            ^^ string "],\"opt_stmts\":"
            ^^ (match opt_statements with
                | Some stmts -> string "[" ^^ separate (string ",") (List.map pp_stmt stmts) ^^ string "]"
                | None -> string "null")
            ^^ string ",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Stmt_For (identifier, expression1, direction, expression2, statements, location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"For\",\"node_data\":{\"serde_tag\":\"StmtFor\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"expr1\":"
            ^^ pp_expr expression1
            ^^ string ",\"direction\":"
            ^^ pp_direction direction
            ^^ string ",\"expr2\":"
            ^^ pp_expr expression2
            ^^ string ",\"stmts\":["
            ^^ separate (string ",") (List.map pp_stmt statements)
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Stmt_While (expression, statements, location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"While\",\"node_data\":{\"serde_tag\":\"StmtWhile\",\"expr\":"
            ^^ pp_expr expression
            ^^ string ",\"stmts\":["
            ^^ separate (string ",") (List.map pp_stmt statements)
            ^^ string "],\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Stmt_Repeat (statements, expression, location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"Repeat\",\"node_data\":{\"serde_tag\":\"StmtRepeat\",\"stmts\":["
            ^^ separate (string ",") (List.map pp_stmt statements)
            ^^ string "],\"expr\":"
            ^^ pp_expr expression
            ^^ string ",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}"
        | Stmt_Try (statements, identifier, catchers, opt_statements, location) -> string "{\"node_type\":\"Stmt\",\"node_subtype\":\"Try\",\"node_data\":{\"serde_tag\":\"StmtTry\",\"stmts\":["
            ^^ separate (string ",") (List.map pp_stmt statements)
            ^^ string "],\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"catchers\":["
            ^^ separate (string ",") (List.map pp_catcher catchers)
            ^^ string "],\"opt_stmts\":"
            ^^ (match opt_statements with
                | Some stmts -> string "[" ^^ separate (string ",") (List.map pp_stmt stmts) ^^ string "]"
                | None -> string "null")
            ^^ string ",\"l\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String (pp_loc location)))
            ^^ string "}"
            ^^ string "}" }}
    | simple_stmt        :: :: Simple      {{ quotient-remove }} {{ ocaml [[simple_stmt]] }}
    | compound_stmt      :: :: Compound    {{ quotient-remove }} {{ ocaml [[compound_stmt]] }}

compound_stmt :: 'Stmt_' ::= {{ quotient-with stmt }}
    {{ aux _ l }}
    | conditional_stmt   :: :: Conditional {{ quotient-remove }} {{ ocaml [[conditional_stmt]] }}
    | repetitive_stmt    :: :: Repetitive  {{ quotient-remove }} {{ ocaml [[repetitive_stmt]] }}
    | catch_stmt         :: :: Catch       {{ quotient-remove }} {{ ocaml [[catch_stmt]] }}


simple_stmt_list :: 'SimpleStmtList_' ::=
    {{ phantom }} {{ ocaml stmt list }}
    | simple_stmt1 ... simple_stmtn :: :: Simple {{ quotient-remove }} {{ ocaml [[simple_stmt1...simple_stmtn]] }}

% It may be possible to simplify the following because we made normal if statements more flexible - experimentation needed
simple_if_stmt :: 'SimpleIfStmts_' ::=
    {{ phantom }} {{ ocaml stmt }}
    | if expr then simple_stmt_list1 simple_elsif1 .. simple_elsifn  else simple_stmt_list2 EOL :: :: If {{ quotient-remove }} {{ ocaml Stmt_If([[expr]], [[simple_stmt_list1]], [[simple_elsif1 .. simple_elsifn]], [[simple_stmt_list2]], Range($symbolstartpos, $endpos)) }}
    | if expr then simple_stmt_list1 simple_elsif1 .. simple_elsifn  EOL :: :: IfNoElse {{ quotient-remove }} {{ ocaml Stmt_If([[expr]], [[simple_stmt_list1]], [[simple_elsif1 .. simple_elsifn]], [], Range($symbolstartpos, $endpos)) }}

simple_elsif :: 'S_Elsif_' ::= {{ quotient-with s_elsif }}
    | elsif expr then simple_stmt_list  :: :: Simple  {{ quotient-remove }} {{ ocaml S_Elsif_Cond([[expr]], [[simple_stmt_list]]) }}

simple_stmts :: 'SimpleStmts_' ::=
    {{ phantom }} {{ ocaml stmt list }}
    | simple_stmt_list simple_if_stmt :: :: ListIf   {{ quotient-remove }} {{ ocaml [[simple_stmt_list]] @ [ [[simple_if_stmt]] ] }}
    | simple_stmt_list EOL            :: :: List     {{ quotient-remove }} {{ ocaml [[simple_stmt_list]] }}


stmts :: 'Stmts_' ::=
    {{ phantom }} {{ ocaml stmt list }}
    | simple_stmts    :: :: Simple   {{ quotient-remove }} {{ ocaml [[simple_stmts]] }}
    | compound_stmt   :: :: Compound {{ quotient-remove }} {{ ocaml [ [[compound_stmt]] ] }}

indented_block :: 'Block_' ::=
    {{ phantom }} {{ ocaml stmt list }}
    {{ pp-raw x = (nest 4 (lbracket
                          ^^ hardline
                          ^^ (separate hardline (List.map pp_raw_stmt x))))
                  ^^ hardline
                  ^^ rbracket
    }}
    {{ pp     x = (nest 4 (lbrace
                              ^^ hardline
                              ^^ if (match x with [] -> true | _ -> false) then
                                    string "pass;"
                                 else
                                    (separate hardline (List.map pp_stmt x))
                  ))
                  ^^ hardline
                  ^^ rbrace
    }}
    | EOL INDENT stmts1 ... stmtsn DEDENT :: :: Indented
                                           {{ ocaml List.concat [[stmts1...stmtsn]] }}

possibly_empty_block :: 'Block_' ::= {{ quotient-with indented_block }}
    | indented_block :: :: EIndented {{ quotient-remove }} {{ ocaml [[indented_block]] }}
    | simple_stmts   :: :: ESimple   {{ quotient-remove }} {{ com statements on same line }} {{ ocaml [[simple_stmts]] }}
    | EOL            :: :: Empty     {{ quotient-remove }} {{ ocaml [] }}

opt_indented_block :: 'Block_' ::= {{ quotient-with indented_block }}
    | indented_block :: :: PE_EIndented {{ quotient-remove }} {{ ocaml [[indented_block]] }}
    | EOL            :: :: PE_Empty     {{ quotient-remove }} {{ ocaml [] }}

% special type of block only found in if-statements
% (distinguishing this helps avoid the dangling else problem)
nonempty_block :: 'Block_' ::= {{ quotient-with indented_block }}
    | indented_block :: :: NEIndented {{ quotient-remove }} {{ ocaml [[indented_block]] }}
    | simple_stmts   :: :: NESimple   {{ quotient-remove }} {{ com statements on same line }} {{ ocaml [[simple_stmts]] }}



assignment_stmt :: 'Stmt_' ::= {{ quotient-with stmt }}
    {{ aux _ l }}
    | ty ident1 , ... , identn ;   :: :: VarDeclsNoInit
    | ty ident = expr ;            :: :: VarDecl
    | constant ty ident = expr ;   :: :: ConstDecl
    | lexpr = expr ;               :: :: Assign

lexpr :: 'LExpr_' ::=
    {{ pp es = match es with
    | LExpr_Wildcard -> string "{\"node_type\":\"LExpr\",\"node_subtype\":\"Wildcard\",\"node_data\":null}"
    | LExpr_Var identifier -> string "{\"node_type\":\"LExpr\",\"node_subtype\":\"Var\",\"node_data\":{\"serde_tag\":\"LExprVar\",\"ident\":\""
        ^^ pp_ident identifier
        ^^ string "\"}"
        ^^ string "}"
    | LExpr_Field (left_expression, identifier) -> string "{\"node_type\":\"LExpr\",\"node_subtype\":\"Field\",\"node_data\":{\"serde_tag\":\"LExprField\",\"l_expr\":"
        ^^ pp_lexpr left_expression
        ^^ string ",\"ident\":\""
        ^^ pp_ident identifier
        ^^ string "\"}"
        ^^ string "}"
    | LExpr_Fields (left_expression, identifiers) -> string "{\"node_type\":\"LExpr\",\"node_subtype\":\"Fields\",\"node_data\":{\"serde_tag\":\"LExprFields\",\"l_expr\":"
        ^^ pp_lexpr left_expression
        ^^ string ",\"idents\":["
        ^^ separate (string ",") (List.map (fun ident -> string "\"" ^^ pp_ident ident ^^ string "\"") identifiers)
        ^^ string "]}"
        ^^ string "}"
    | LExpr_Slices (left_expression, slices) -> string "{\"node_type\":\"LExpr\",\"node_subtype\":\"Slices\",\"node_data\":{\"serde_tag\":\"LExprSlices\",\"l_expr\":"
        ^^ pp_lexpr left_expression
        ^^ string ",\"slices\":["
        ^^ separate (string ",") (List.map pp_slice slices)
        ^^ string "]}"
        ^^ string "}"
    | LExpr_BitTuple left_expressions -> string "{\"node_type\":\"LExpr\",\"node_subtype\":\"BitTuple\",\"node_data\":{\"serde_tag\":\"LExprBitTuple\",\"l_exprs\":["
        ^^ separate (string ",") (List.map pp_lexpr left_expressions)
        ^^ string "]}"
        ^^ string "}"
    | LExpr_Tuple left_expressions -> string "{\"node_type\":\"LExpr\",\"node_subtype\":\"Tuple\",\"node_data\":{\"serde_tag\":\"LExprTuple\",\"l_exprs\":["
        ^^ separate (string ",") (List.map pp_lexpr left_expressions)
        ^^ string "]}"
        ^^ string "}"
    | LExpr_Array (left_expression, expression) -> string "{\"node_type\":\"LExpr\",\"node_subtype\":\"Array\",\"node_data\":{\"serde_tag\":\"LExprArray\",\"l_expr\":"
        ^^ pp_lexpr left_expression
        ^^ string ",\"expr\":"
        ^^ pp_expr expression
        ^^ string "}"
        ^^ string "}"
    | LExpr_Write (identifier, expressions1, expressions2) -> string "{\"node_type\":\"LExpr\",\"node_subtype\":\"Write\",\"node_data\":{\"serde_tag\":\"LExprWrite\",\"ident\":\""
        ^^ pp_ident identifier
        ^^ string "\",\"exprs1\":["
        ^^ separate (string ",") (List.map pp_expr expressions1)
        ^^ string "],\"exprs2\":["
        ^^ separate (string ",") (List.map pp_expr expressions2)
        ^^ string "]}"
        ^^ string "}"
    | LExpr_ReadWrite (identifier1, identifier2, expressions1, expressions2) -> string "{\"node_type\":\"LExpr\",\"node_subtype\":\"ReadWrite\",\"node_data\":{\"serde_tag\":\"LExprReadWrite\",\"ident1\":\""
        ^^ pp_ident identifier1
        ^^ string "\",\"ident2\":\""
        ^^ pp_ident identifier2
        ^^ string "\",\"exprs1\":["
        ^^ separate (string ",") (List.map pp_expr expressions1)
        ^^ string "],\"exprs2\":["
        ^^ separate (string ",") (List.map pp_expr expressions2)
        ^^ string "]}"
        ^^ string "}" }}
    | -                                   ::   :: Wildcard
    | qualident                           ::   :: Var
    | lexpr . ident                       ::   :: Field
    | lexpr . [ ident1 , ... , identn ]   ::   :: Fields
    | lexpr [ slice1 , .. , slicen ]      ::   :: Slices
    | [ lexpr1 , .... , lexprn ]          ::   :: BitTuple
    | ( lexpr1 , .... , lexprn )          ::   :: Tuple
    | ( lexpr )                           :: S :: Parens {{ ocaml [[lexpr]] }}

lexpr_spice :: 'LExpr_' ::= {{ quotient-with lexpr }}
    | __array     lexpr         [ expr ]  :: :: Array     {{ com spice for desugaring array assignment }}
    | __write     ident         {{ expr1' , .. , exprm' }} [ expr1 , .. , exprn ] :: :: Write     {{ com spice for desugaring setter procedure call }}
    | __readwrite ident1 ident2 {{ expr1' , .. , exprm' }} [ expr1 , .. , exprn ] :: :: ReadWrite {{ com spice for desugaring read-modify-write function+procedure call }}

simple_stmt :: 'Stmt_' ::= {{ quotient-with stmt }}
    {{ aux _ l }}
    | assignment_stmt                     :: :: Assignment {{ quotient-remove }} {{ ocaml [[assignment_stmt]] }}
    | qualident ( expr1 , .. , exprn ) ;  :: S :: Call   {{ com procedure call }} {{ ocaml Stmt_TCall([[qualident]], [], [[expr1 .. exprn]], Range($symbolstartpos,$endpos)) }}
    | return expr ;                       ::   :: FunReturn {{ com function return }}
    | return ;                            ::   :: ProcReturn {{ com procedure return }}
    | assert expr ;                       ::   :: Assert {{ com assertion }}
    | UNPREDICTABLE ( ) ;                 ::   :: Unpred {{ com underspecified behaviour }}
    | CONSTRAINED_UNPREDICTABLE ;         ::   :: ConstrainedUnpred
    | IMPLEMENTATION_DEFINED ( ident ) ;  ::   :: ImpDef {{ com underspecified behaviour }}
    | UNDEFINED ( ) ;                     ::   :: Undefined
    | __ExceptionTaken ( ) ;              ::   :: ExceptionTaken
    | UNPREDICTABLE ;                     ::   :: Dep_Unpred      {{ com DEPRECATED }}
    | IMPLEMENTATION_DEFINED stringLit ;  ::   :: Dep_ImpDef      {{ com DEPRECATED }}
    | IMPLEMENTATION_DEFINED ;            :: S :: Dep_ImpDefNoStr {{ com DEPRECATED }} {{ ocaml Stmt_Dep_ImpDef("", Range($symbolstartpos,$endpos)) }}
    | UNDEFINED ;                         ::   :: Dep_Undefined   {{ com DEPRECATED }}
    | SEE ( expr ) ;                      ::   :: See
    | SEE stringLit ;                     :: S :: Dep_SeeString {{ ocaml Stmt_See(Expr_LitString([[stringLit]]), Range($symbolstartpos, $endpos)) }} {{ com DEPRECATED }}
    | SEE ident ;                         :: S :: Dep_SeeIdent  {{ ocaml Stmt_See(Expr_LitString(pprint_ident [[ident]]), Range($symbolstartpos, $endpos)) }} {{ com DEPRECATED }}
    | throw ident ;                       ::   :: Throw
    | __decode ident expr ;               ::   :: DecodeExecute {{ com decode and execute instruction }}

stmt_spice :: 'Stmt_' ::= {{ quotient-with stmt }}
    | qualident {{ expr1' , .. , exprm' }} ( expr1 , .. , exprn ) ;  ::   :: TCall  {{ com spice for procedure call with explicit type parameters }}

conditional_stmt :: 'Stmt_' ::= {{ quotient-with stmt }}
    {{ aux _ l }}
    | if expr then opt_indented_block
      s_elsif1
      ..
      s_elsifn
      optional_else
      :: :: If

    | if expr then simple_stmts
      s_elsif1
      ..
      s_elsifn
      optional_else
      :: S :: If2 {{ ocaml Stmt_If([[expr]],[[simple_stmts]],[[s_elsif1 .. s_elsifn]],[[optional_else]], Range($symbolstartpos, $endpos)) }}

    | if expr then simple_stmt_list1 simple_elsif1 .. simple_elsifn  else simple_stmt_list2 EOL :: :: If3 {{ quotient-remove }} {{ ocaml Stmt_If([[expr]], [[simple_stmt_list1]], [[simple_elsif1 .. simple_elsifn]], [[simple_stmt_list2]], Range($symbolstartpos, $endpos)) }}

    | case expr of EOL
      INDENT
          alt1 ... altn
          opt_otherwise
      DEDENT
      :: :: Case

s_elsif :: 'S_Elsif_' ::=
    {{ pp es = match es with
        | S_Elsif_Cond (expression, statements) -> string "{\"node_type\":\"SElsif\",\"node_subtype\":\"Cond\",\"node_data\":{\"serde_tag\":\"SElsifCond\",\"expr\":"
            ^^ pp_expr expression
            ^^ string ",\"stmts\":["
            ^^ separate (string ",") (List.map pp_stmt statements)
            ^^ string "]}"
            ^^ string "}" }}
    | elsif expr then opt_indented_block  ::   :: Cond
    | elsif expr then simple_stmts        :: S :: Cond2 {{ ocaml S_Elsif_Cond([[expr]], [[simple_stmts]]) }}

optional_else :: 'S_Else' ::=
    {{ phantom }} {{ ocaml stmt list }}
    {{ pp-raw x = match x with [] -> string ""
                             | ys -> string "(else " ^^ separate (string "\n") (List.map pp_raw_stmt ys) ^^ string ")" }}
    {{ pp     x = match x with [] -> string ""
                             | ys -> string "else" ^^ hardline
                                         ^^ (nest 4 (separate (string "\n") (List.map pp_stmt ys)))
    }}
    | else opt_indented_block :: :: ElseBlock  {{ ocaml [[opt_indented_block]] }}
    | else simple_stmts                  :: :: ElseSimple {{ ocaml [[simple_stmts]] }}
    |                                    :: :: NoElse     {{ ocaml [] }}

alt :: 'Alt_' ::=
    {{ pp es = match es with
    | Alt_Alt (patterns, opt_expression, statements) -> string "{\"node_type\":\"Alt\",\"node_subtype\":\"Alt\",\"node_data\":{\"serde_tag\":\"Alt\",\"patterns\":["
        ^^ separate (string ",") (List.map pp_pattern patterns)
        ^^ string "],\"opt_expr\":"
        ^^ (match opt_expression with
            | Some expr -> pp_expr expr
            | None -> string "null")
        ^^ string ",\"stmts\":["
        ^^ separate (string ",") (List.map pp_stmt statements)
        ^^ string "]}"
        ^^ string "}" }}
    | when pattern1 , ... , patternn opt_altcond possibly_empty_block ::   :: Alt
    | when pattern1 , ... , patternn opt_altcond simple_if_stmt       :: S :: Alt2 {{ ocaml Alt_Alt([[pattern1 ... patternn]], [[opt_altcond]], [ [[simple_if_stmt]] ]) }}

opt_otherwise :: 'OptOtherwise_' ::=
    {{ phantom }} {{ ocaml (stmt list) option }}
    {{ pp-raw x = match x with Some(ys) -> string "Some(" ^^ separate (string "\n") (List.map pp_raw_stmt ys) ^^ string ")" | None -> string "None" }}
    {{ pp     x = match x with Some(ys) -> string "otherwise" ^^ hardline
                                           ^^ (nest 4 (separate (string "\n") (List.map pp_stmt ys)))
                             | None -> string "" }}
    | otherwise possibly_empty_block   :: :: Some {{ ocaml Some([[possibly_empty_block]]) }}
    |                                  :: :: None {{ ocaml None }}

opt_altcond :: 'AltCond_' ::= {{ ocaml expr option }}
    {{ phantom }} {{ ocaml expr option }}
    {{ pp-raw x = match x with Some(y) -> string "Some(" ^^ pp_raw_expr y ^^ string ")" | None -> string "None" }}
    {{ pp     x = match x with Some(y) -> pp_expr y | None -> string "" }}
    | && expr => :: :: Some {{ ocaml Some([[expr]]) }}
    |         => :: :: None0 {{ ocaml None }}
    |            :: :: None {{ ocaml None }}

pattern :: 'Pat_' ::=
    {{ pp es = match es with
        | Pat_LitInt integerLiteral -> string "{\"node_type\":\"Pat\",\"node_subtype\":\"LitInt\",\"node_data\":{\"serde_tag\":\"PatLitInt\",\"int_lit\":"
            ^^ string (Yojson.Safe.to_string (`String integerLiteral))
            ^^ string "}"
            ^^ string "}"
        | Pat_LitHex hexadecimalLiteral -> string "{\"node_type\":\"Pat\",\"node_subtype\":\"LitHex\",\"node_data\":{\"serde_tag\":\"PatLitHex\",\"hex_lit\":"
            ^^ string (Yojson.Safe.to_string (`String hexadecimalLiteral))
            ^^ string "}"
            ^^ string "}"
        | Pat_LitBits bitsLiteral -> string "{\"node_type\":\"Pat\",\"node_subtype\":\"LitBits\",\"node_data\":{\"serde_tag\":\"PatLitBits\",\"bits_lit\":"
            ^^ string (Yojson.Safe.to_string (`String bitsLiteral))
            ^^ string "}"
            ^^ string "}"
        | Pat_LitMask maskLiteral -> string "{\"node_type\":\"Pat\",\"node_subtype\":\"LitMask\",\"node_data\":{\"serde_tag\":\"PatLitMask\",\"mask_lit\":"
            ^^ string (Yojson.Safe.to_string (`String maskLiteral))
            ^^ string "}"
            ^^ string "}"
        | Pat_Const identifier -> string "{\"node_type\":\"Pat\",\"node_subtype\":\"Const\",\"node_data\":{\"serde_tag\":\"PatConst\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\"}"
            ^^ string "}"
        | Pat_Wildcard -> string "{\"node_type\":\"Pat\",\"node_subtype\":\"Wildcard\",\"node_data\":null}"
        | Pat_Tuple patterns -> string "{\"node_type\":\"Pat\",\"node_subtype\":\"Tuple\",\"node_data\":{\"serde_tag\":\"PatTuple\",\"patterns\":["
            ^^ separate (string ",") (List.map pp_pattern patterns)
            ^^ string "]}"
            ^^ string "}"
        | Pat_Set patterns -> string "{\"node_type\":\"Pat\",\"node_subtype\":\"Set\",\"node_data\":{\"serde_tag\":\"PatSet\",\"patterns\":["
            ^^ separate (string ",") (List.map pp_pattern patterns)
            ^^ string "]}"
            ^^ string "}"
        | Pat_Range (expression1, expression2) -> string "{\"node_type\":\"Pat\",\"node_subtype\":\"Range\",\"node_data\":{\"serde_tag\":\"PatRange\",\"expr1\":"
            ^^ pp_expr expression1
            ^^ string ",\"expr2\":"
            ^^ pp_expr expression2
            ^^ string "}"
            ^^ string "}"
        | Pat_Single expression -> string "{\"node_type\":\"Pat\",\"node_subtype\":\"Single\",\"node_data\":{\"serde_tag\":\"PatSingle\",\"expr\":"
            ^^ pp_expr expression
            ^^ string "}"
            ^^ string "}" }}
    | intLit                             :: :: LitInt
    | hexLit                             :: :: LitHex
    | bitsLit                            :: :: LitBits
    | maskLit                            :: :: LitMask
    | qualident                          :: :: Const
    | -                                  :: :: Wildcard
    | ( pattern1  , .... , patternn )    :: :: Tuple
    | { apattern1 , ..   , apatternn }   :: :: Set

apattern :: 'Pat_' ::= {{ quotient-with pattern }}
    | expr1 '..' expr2                   :: :: Range
    | expr                               :: :: Single

repetitive_stmt :: 'Stmt_' ::= {{ quotient-with stmt }}
    {{ aux _ l }}
    | for ident = expr1 direction expr2 indented_block :: :: For
    | while expr do indented_block                     :: :: While
    | repeat indented_block until expr ; EOL           :: :: Repeat

direction :: 'Direction_' ::=
    {{ pp es = match es with
        | Direction_Up -> string "{\"node_type\":\"Direction\",\"node_subtype\":\"Up\",\"node_data\":null}"
        | Direction_Down -> string "{\"node_type\":\"Direction\",\"node_subtype\":\"Down\",\"node_data\":null}" }}
    | to      :: :: Up
    | downto  :: :: Down

catch_stmt :: 'Stmt_' ::= {{ quotient-with stmt }}
    {{ aux _ l }}
    | try indented_block
      catch ident EOL
      INDENT
          catcher1 .. catchern
          opt_otherwise
      DEDENT
      :: :: Try

catcher :: 'Catcher_' ::=
    {{ pp es = match es with
        | Catcher_Guarded (expression, statements) -> string "{\"node_type\":\"Catcher\",\"node_subtype\":\"Guarded\",\"node_data\":{\"serde_tag\":\"CatcherGuarded\",\"expr\":"
            ^^ pp_expr expression
            ^^ string ",\"stmts\":["
            ^^ separate (string ",") (List.map pp_stmt statements)
            ^^ string "]}"
            ^^ string "}" }}
    | when expr opt_indented_block  :: :: Guarded

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Expressions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

expr :: 'Expr_' ::=
    {{ pp es = match es with
        | Expr_If (if_cond_expression, if_body_expression, e_elsifs, else_body_expression) -> string "{\"node_type\":\"Expr\",\"node_subtype\":\"If\",\"node_data\":{\"serde_tag\":\"ExprIf\",\"if_cond_expr\":"
            ^^ pp_expr if_cond_expression
            ^^ string ",\"if_body_expr\":"
            ^^ pp_expr if_body_expression
            ^^ string ",\"e_elsifs\":["
            ^^ separate (string ",") (List.map pp_e_elsif e_elsifs)
            ^^ string "],\"else_body_expr\":"
            ^^ pp_expr else_body_expression
            ^^ string "}"
            ^^ string "}"
        | Expr_Binop (left_expression, binary_operator, right_expression) -> string "{\"node_type\":\"Expr\",\"node_subtype\":\"Binop\",\"node_data\":{\"serde_tag\":\"ExprBinop\",\"l_expr\":"
            ^^ pp_expr left_expression
            ^^ string ",\"binop\":"
            ^^ pp_binop binary_operator
            ^^ string ",\"r_expr\":"
            ^^ pp_expr right_expression
            ^^ string "}"
            ^^ string "}"
        | Expr_Unop (unary_operator, expression) -> string "{\"node_type\":\"Expr\",\"node_subtype\":\"Unop\",\"node_data\":{\"serde_tag\":\"ExprUnop\",\"unop\":"
            ^^ pp_unop unary_operator
            ^^ string ",\"expr\":"
            ^^ pp_expr expression
            ^^ string "}"
            ^^ string "}"
        | Expr_Field (expression, identifier) -> string "{\"node_type\":\"Expr\",\"node_subtype\":\"Field\",\"node_data\":{\"serde_tag\":\"ExprField\",\"expr\":"
            ^^ pp_expr expression
            ^^ string ",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\"}"
            ^^ string "}"
        | Expr_Fields (expression, identifiers) -> string "{\"node_type\":\"Expr\",\"node_subtype\":\"Fields\",\"node_data\":{\"serde_tag\":\"ExprFields\",\"expr\":"
            ^^ pp_expr expression
            ^^ string ",\"idents\":["
            ^^ separate (string ",") (List.map (fun ident -> string "\"" ^^ pp_ident ident ^^ string "\"") identifiers)
            ^^ string "]}"
            ^^ string "}"
        | Expr_Slices (expression, slices) -> string "{\"node_type\":\"Expr\",\"node_subtype\":\"Slices\",\"node_data\":{\"serde_tag\":\"ExprSlices\",\"expr\":"
            ^^ pp_expr expression
            ^^ string ",\"slices\":["
            ^^ separate (string ",") (List.map pp_slice slices)
            ^^ string "]}"
            ^^ string "}"
        | Expr_In (expression, pattern) -> string "{\"node_type\":\"Expr\",\"node_subtype\":\"In\",\"node_data\":{\"serde_tag\":\"ExprIn\",\"expr\":"
            ^^ pp_expr expression
            ^^ string ",\"pattern\":"
            ^^ pp_pattern pattern
            ^^ string "}"
            ^^ string "}"
        | Expr_Var (identifier) -> string "{\"node_type\":\"Expr\",\"node_subtype\":\"Var\",\"node_data\":{\"serde_tag\":\"ExprVar\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\"}"
            ^^ string "}"
        | Expr_Parens (expression) -> string "{\"node_type\":\"Expr\",\"node_subtype\":\"Parens\",\"node_data\":{\"serde_tag\":\"ExprParens\",\"expr\":"
            ^^ pp_expr expression
            ^^ string "}"
            ^^ string "}"
        | Expr_Tuple (expressions) -> 
            string "{\"node_type\":\"Expr\",\"node_subtype\":\"Tuple\",\"node_data\":{\"serde_tag\":\"ExprTuple\",\"exprs\":["
            ^^ separate (string ",") (List.map pp_expr expressions)
            ^^ string "]}"
            ^^ string "}"
        | Expr_Unknown (typ) -> string "{\"node_type\":\"Expr\",\"node_subtype\":\"Unknown\",\"node_data\":{\"serde_tag\":\"ExprUnknown\",\"ty\":"
            ^^ pp_ty typ
            ^^ string "}"
            ^^ string "}"
        | Expr_ImpDef (typ, opt_stringLiteral) -> string "{\"node_type\":\"Expr\",\"node_subtype\":\"ImpDef\",\"node_data\":{\"serde_tag\":\"ExprImpDef\",\"ty\":"
            ^^ pp_ty typ
            ^^ string ",\"opt_string_lit\":"
            ^^ (match opt_stringLiteral with
                | Some s -> PPrint.string (Yojson.Safe.to_string (`String s))
                | None -> string "null")
            ^^ string "}"
            ^^ string "}"
        | Expr_TApply (identifier, expressions1, expressions2) -> string "{\"node_type\":\"Expr\",\"node_subtype\":\"TApply\",\"node_data\":{\"serde_tag\":\"ExprTApply\",\"ident\":\""
            ^^ pp_ident identifier
            ^^ string "\",\"exprs1\":["
            ^^ separate (string ",") (List.map pp_expr expressions1)
            ^^ string "],\"exprs2\":["
            ^^ separate (string ",") (List.map pp_expr expressions2)
            ^^ string "]}"
            ^^ string "}"
        | Expr_Array (expression1, expression2) -> string "{\"node_type\":\"Expr\",\"node_subtype\":\"Array\",\"node_data\":{\"serde_tag\":\"ExprArray\",\"expr1\":"
            ^^ pp_expr expression1
            ^^ string ",\"expr2\":"
            ^^ pp_expr expression2
            ^^ string "}"
            ^^ string "}"
        | Expr_LitInt (integerLiteral) -> string "{\"node_type\":\"Expr\",\"node_subtype\":\"LitInt\",\"node_data\":{\"serde_tag\":\"ExprLitInt\",\"int_lit\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String integerLiteral))
            ^^ string "}"
            ^^ string "}"
        | Expr_LitHex (hexadecimalLiteral) -> string "{\"node_type\":\"Expr\",\"node_subtype\":\"LitHex\",\"node_data\":{\"serde_tag\":\"ExprLitHex\",\"hex_lit\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String hexadecimalLiteral))
            ^^ string "}"
            ^^ string "}"
        | Expr_LitReal (realLiteral) -> string "{\"node_type\":\"Expr\",\"node_subtype\":\"LitReal\",\"node_data\":{\"serde_tag\":\"ExprLitReal\",\"real_lit\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String realLiteral))
            ^^ string "}"
            ^^ string "}"
        | Expr_LitBits (bitsLiteral) -> string "{\"node_type\":\"Expr\",\"node_subtype\":\"LitBits\",\"node_data\":{\"serde_tag\":\"ExprLitBits\",\"bits_lit\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String bitsLiteral))
            ^^ string "}"
            ^^ string "}"
        | Expr_LitMask (maskLiteral) -> string "{\"node_type\":\"Expr\",\"node_subtype\":\"LitMask\",\"node_data\":{\"serde_tag\":\"ExprLitMask\",\"mask_lit\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String maskLiteral))
            ^^ string "}"
            ^^ string "}"
        | Expr_LitString (stringLiteral) -> string "{\"node_type\":\"Expr\",\"node_subtype\":\"LitString\",\"node_data\":{\"serde_tag\":\"ExprLitString\",\"string_lit\":"
            ^^ PPrint.string (Yojson.Safe.to_string (`String stringLiteral))
            ^^ string "}"
            ^^ string "}" }}
    | conditional_expression :: :: Conditional {{ quotient-remove }} {{ ocaml [[conditional_expression]] }}

% dexpr in hand parser
conditional_expression :: 'Expr_' ::= {{ quotient-with expr }}
    | if cexpr1 then expr1 e_elsif1 .. e_elsifn else expr2   :: :: If
    | cexpr                                                  :: :: CExpr  {{ quotient-remove }} {{ ocaml [[cexpr]] }}

e_elsif :: 'E_Elsif_' ::= {{ ocaml expr * expr }}
    {{ pp es = match es with 
        | E_Elsif_Cond (expression1, expression2) -> string "{\"node_type\":\"EElsif\",\"node_subtype\":\"Cond\",\"node_data\":{\"serde_tag\":\"EElsifCond\",\"expr1\":"
            ^^ pp_expr expression1
            ^^ string ",\"expr2\":"
            ^^ pp_expr expression2
            ^^ string "}"
            ^^ string "}" }}
    | elsif expr1 then expr2                                 :: :: Cond

cexpr :: 'Expr_' ::= {{ quotient-with expr }}
    | bexpr factor1 .. factorn    :: :: Binops  {{ quotient-remove }} {{ ocaml buildExpression [[bexpr]] [[factor1..factorn]] (Range($startpos([[bexpr]]),$endpos([[factor1..factorn]]))) }}

% the following definition is not referenced but is included to cause  Expr_Binop to be defined
zexpr :: 'Expr_' ::= {{ quotient-with expr }}
    | expr1 binop expr2 :: :: Binop

factor :: 'Factor_' ::=
    | binop_or_concat bexpr :: :: BinOp

binop_or_concat :: 'Binop_' ::= {{ quotient-with binop }}
    | binop    :: :: NotConcat {{ quotient-remove }} {{ ocaml [[binop]] }}
    | :        :: :: Concat

binop :: 'Binop_' ::=
    {{ pp es = match es with
        | Binop_Eq -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"Eq\",\"node_data\":null}"
        | Binop_NtEq -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"NtEq\",\"node_data\":null}"
        | Binop_Gt -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"Gt\",\"node_data\":null}"
        | Binop_GtEq -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"GtEq\",\"node_data\":null}"
        | Binop_Lt -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"Lt\",\"node_data\":null}"
        | Binop_LtEq -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"LtEq\",\"node_data\":null}"
        | Binop_Plus -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"Plus\",\"node_data\":null}"
        | Binop_Minus -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"Minus\",\"node_data\":null}"
        | Binop_Multiply -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"Multiply\",\"node_data\":null}"
        | Binop_Divide -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"Divide\",\"node_data\":null}"
        | Binop_Power -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"Power\",\"node_data\":null}"
        | Binop_Quot -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"Quot\",\"node_data\":null}"
        | Binop_Rem -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"Rem\",\"node_data\":null}"
        | Binop_Div -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"Div\",\"node_data\":null}"
        | Binop_Mod -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"Mod\",\"node_data\":null}"
        | Binop_ShiftL -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"ShiftL\",\"node_data\":null}"
        | Binop_ShiftR -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"ShiftR\",\"node_data\":null}"
        | Binop_BoolAnd -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"BoolAnd\",\"node_data\":null}"
        | Binop_BoolOr -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"BoolOr\",\"node_data\":null}"
        | Binop_BoolIff -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"BoolIff\",\"node_data\":null}"
        | Binop_BoolImplies -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"BoolImplies\",\"node_data\":null}"
        | Binop_BitOr -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"BitOr\",\"node_data\":null}"
        | Binop_BitEor -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"BitEor\",\"node_data\":null}"
        | Binop_BitAnd -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"BitAnd\",\"node_data\":null}"
        | Binop_Append -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"Append\",\"node_data\":null}"
        | Binop_Concat -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"Concat\",\"node_data\":null}"
        | Binop_DUMMY -> string "{\"node_type\":\"Binop\",\"node_subtype\":\"DUMMY\",\"node_data\":null}" }}
    | ==      :: :: Eq
    | !=      :: :: NtEq
    | >       :: :: Gt
    | >=      :: :: GtEq
    | <       :: :: Lt
    | <=      :: :: LtEq
    | +       :: :: Plus
    | -       :: :: Minus
    | *       :: :: Multiply
    | /       :: :: Divide
    | ^       :: :: Power
    | QUOT    :: :: Quot
    | REM     :: :: Rem
    | DIV     :: :: Div
    | MOD     :: :: Mod
    | <<      :: :: ShiftL
    | >>      :: :: ShiftR
    | &&      :: :: BoolAnd
    | ||      :: :: BoolOr
    | IFF     :: :: BoolIff
    | IMPLIES :: :: BoolImplies
    | OR      :: :: BitOr
    | EOR     :: :: BitEor
    | AND     :: :: BitAnd
    | ++      :: :: Append

dummy_binop :: 'Binop_' ::= {{ quotient-with binop }}
    | :: :: DUMMY

bexpr :: 'Expr_' ::= {{ quotient-with expr }}
    | unop fexpr                                 :: :: Unop    {{ com unary operator }}
    | fexpr                                      :: :: FExpr   {{ quotient-remove }} {{ ocaml [[fexpr]] }}

fexpr :: 'Expr_' ::= {{ quotient-with expr }}
    | fexpr . ident                              :: :: Field   {{ com field selection }}
    | fexpr . [ ident1 , ... , identn ]          :: :: Fields  {{ com multiple field selection }}
    | fexpr   [ slice1 , .. , slicen ]           :: :: Slices  {{ com bitslice }}
    | fexpr 'IN' pattern                         :: :: In      {{ com pattern match }}
    | aexpr                                      :: :: AExpr   {{ quotient-remove }} {{ ocaml [[aexpr]] }}

aexpr :: 'Expr_' ::= {{ quotient-with expr }}
    | literal_expression                         ::   :: Lit {{ quotient-remove }} {{ ocaml [[literal_expression]] }}
    | qualident                                  ::   :: Var
    | qualident ( expr1 , .. , exprn )           :: S :: Apply   {{ ocaml Expr_TApply([[qualident]], [], [[expr1 .. exprn]]) }}
    | ( expr )                                   ::   :: Parens
    | ( expr1 , .... , exprn )                   ::   :: Tuple     {{ com tuple }}
    | ty UNKNOWN                                 ::   :: Unknown
    | ty IMPLEMENTATION_DEFINED opt_stringLit    ::   :: ImpDef

expr_spice :: 'Expr_' ::= {{ quotient-with expr }}
    | qualident {{ expr1' , .. , exprm' }} ( expr1 , .. , exprn ) ::   :: TApply  {{ com spice for desugaring function call with explicit type parameters }}
    | __array expr1 [ expr2 ]                    ::   :: Array     {{ com spice for desugaring array accesses }}

opt_stringLit :: 'String_' ::=
    {{ phantom }} {{ ocaml string option }}
    {{ pp-raw x = match x with Some(y) -> string "Some(" ^^ string y ^^ string ")" | None -> string "None" }}
    {{ pp     x = match x with Some(y) -> string y | None -> string "" }}
    | stringLit                                  :: :: Some {{ ocaml Some([[stringLit]]) }}
    |                                            :: :: None {{ ocaml None }}

unop :: 'Unop_' ::=
    {{ pp es = match es with
        | Unop_Negate -> string "{\"node_type\":\"Unop\",\"node_subtype\":\"Negate\",\"node_data\":null}"
        | Unop_BoolNot -> string "{\"node_type\":\"Unop\",\"node_subtype\":\"BoolNot\",\"node_data\":null}"
        | Unop_BitsNot -> string "{\"node_type\":\"Unop\",\"node_subtype\":\"BitsNot\",\"node_data\":null}" }}
    | -        :: :: Negate
    | !        :: :: BoolNot
    | NOT      :: :: BitsNot

slice :: 'Slice_' ::=
    {{ pp es = match es with
        | Slice_Single expression -> string "{\"node_type\":\"Slice\",\"node_subtype\":\"Single\",\"node_data\":{\"serde_tag\":\"SliceSingle\",\"expr\":"
            ^^ pp_expr expression
            ^^ string "}"
            ^^ string "}"
        | Slice_HiLo (high_expression, low_expression) -> string "{\"node_type\":\"Slice\",\"node_subtype\":\"HiLo\",\"node_data\":{\"serde_tag\":\"SliceHiLo\",\"hi_expr\":"
            ^^ pp_expr high_expression
            ^^ string ",\"lo_expr\":"
            ^^ pp_expr low_expression
            ^^ string "}"
            ^^ string "}"
        | Slice_LoWd (low_expression, width_expression) -> string "{\"node_type\":\"Slice\",\"node_subtype\":\"LoWd\",\"node_data\":{\"serde_tag\":\"SliceLoWd\",\"lo_expr\":"
            ^^ pp_expr low_expression
            ^^ string ",\"wd_expr\":"
            ^^ pp_expr width_expression
            ^^ string "}"
            ^^ string "}" }}
    | sexpr            :: :: Single
    | sexpr1 :  sexpr2 :: :: HiLo
    | sexpr1 +: sexpr2 :: :: LoWd

% almost identical to conditional_expression except that it omits : binop
sexpr :: 'Expr_' ::= {{ quotient-with expr }}
    | scexpr                                                 :: :: CExpr2  {{ quotient-remove }} {{ ocaml [[scexpr]] }}
    | if cexpr1 then expr1 e_elsif1 .. e_elsifn else scexpr2 :: :: If2  {{ quotient-remove }} {{ ocaml Expr_If([[cexpr1]], [[expr1]], [[e_elsif1 .. e_elsifn]], [[scexpr2]]) }}

scexpr :: 'Expr_' ::= {{ quotient-with expr }}
    | bexpr sfactor1 .. sfactorn :: :: Binop2  {{ quotient-remove }} {{ ocaml buildExpression [[bexpr]] [[sfactor1..sfactorn]] (Range($startpos([[bexpr]]),$endpos([[sfactor1..sfactorn]]))) }}

sfactor :: 'Factor_' ::= {{ quotient-with factor }}
    | binop bexpr :: :: BinOp2 {{ quotient-remove }} {{ ocaml Factor_BinOp([[binop]], [[bexpr]]) }}

literal_expression :: 'Expr_' ::= {{ quotient-with expr }}
    | intLit                                     :: :: LitInt    {{ com literal decimal integer }}
    | hexLit                                     :: :: LitHex    {{ com literal hexadecimal integer }}
    | realLit                                    :: :: LitReal   {{ com literal real }}
    | bitsLit                                    :: :: LitBits   {{ com literal bitvector }}
    | maskLit                                    :: :: LitMask   {{ com literal bitmask }}
    | stringLit                                  :: :: LitString {{ com literal string }}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Additional entry points used by ASLi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

expr_command :: 'CLI_' ::= {{ menhir-start }}
    {{ phantom }} {{ ocaml expr }}
    {{ pp-raw x = pp_raw_expr x }}
    {{ pp     x = pp_expr     x }}
    | EOL expr :: :: Expr {{ ocaml [[expr]] }}

stmt_command :: 'CLI_' ::= {{ menhir-start }}
    {{ phantom }} {{ ocaml stmt }}
    {{ pp-raw x = pp_raw_stmt x }}
    {{ pp     x = pp_stmt     x }}
    | EOL stmt :: :: Stmt {{ ocaml [[stmt]] }}

impdef_command :: 'CLI_' ::= {{ menhir-start }}
    {{ pp-raw se = match se with (s,e) -> string s ^^ string "=" ^^ pp_raw_expr e }}
    {{ pp     se = match se with (s,e) -> string s ^^ string "=" ^^ pp_expr e }}
    | EOL stringLit = expr :: :: Impdef {{ ocaml ([[stringLit]], [[expr]]) }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Misc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

terminals :: 'terminals_' ::=
    | INDENT :: :: Indent {{ tex \mbox{$\{\!\mid$} }}
    | DEDENT :: :: Dedent {{ tex \mbox{$\mid\!\}$} }}
    | EOL    :: :: EndOfLine {{ tex \mbox{$\hookleftarrow$} }}
    | ^      :: :: Caret     {{ tex \mbox{$\,\hat{}$} }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% End of grammar
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

embed
{{ ocaml

let associativeOperators: binop list =
    [ Binop_Plus
    ; Binop_Multiply
    ; Binop_BoolAnd
    ; Binop_BoolOr
    ; Binop_BitOr
    ; Binop_BitEor
    ; Binop_BitAnd
    ; Binop_Concat
    ; Binop_Append
    ]

(* boolean operators bind least tightly *)
let booleanOperators: binop list =
    [ Binop_BoolAnd
    ; Binop_BoolOr
    ; Binop_BoolIff
    ; Binop_BoolImplies
    ]

(* comparision operators bind less tightly than arithmetic, etc. *)
let comparisionOperators: binop list =
    [ Binop_Eq
    ; Binop_NtEq
    ; Binop_Gt
    ; Binop_GtEq
    ; Binop_Lt
    ; Binop_LtEq
    ]

(* arithmetic and similar operations bind more tightly than comparisions and &&/|| *)
let miscOperators: binop list =
    [ Binop_Plus
    ; Binop_Minus
    ; Binop_Multiply
    ; Binop_Divide
    ; Binop_Power
    ; Binop_Quot
    ; Binop_Rem
    ; Binop_Div
    ; Binop_Mod
    ; Binop_ShiftL
    ; Binop_ShiftR
    ; Binop_BitOr
    ; Binop_BitEor
    ; Binop_BitAnd
    ; Binop_Concat
    ]

let isAssociative (x: binop): bool = List.mem x associativeOperators
let isBoolean     (x: binop): bool = List.mem x booleanOperators
let isComparision (x: binop): bool = List.mem x comparisionOperators
let isMisc        (x: binop): bool = List.mem x miscOperators

(* Is operator x higher priority than y
 * (Binop_DUMMY acts as the lowest priority operation - see below)
 *)
let higherPriorityThan (x: binop) (y: binop): bool option =
    if                             y = Binop_DUMMY    then Some(true)
    else if x = Binop_Power    && y = Binop_Multiply then Some(true)
    else if x = Binop_Power    && y = Binop_Divide   then Some(true)
    else if x = Binop_Power    && y = Binop_Plus     then Some(true)
    else if x = Binop_Power    && y = Binop_Minus    then Some(true)
    else if x = Binop_Multiply && y = Binop_Plus     then Some(true)
    else if x = Binop_Multiply && y = Binop_Minus    then Some(true)
    else if x = Binop_Plus     && y = Binop_Minus    then Some(true)
    else if isMisc x           && isBoolean y        then Some(true)
    else if isMisc x           && isComparision y    then Some(true)
    else if isComparision x    && isBoolean y        then Some(true)

    else if                       x = Binop_DUMMY    then Some(false)
    else if y = Binop_Power    && x = Binop_Multiply then Some(false)
    else if y = Binop_Power    && x = Binop_Divide   then Some(false)
    else if y = Binop_Power    && x = Binop_Plus     then Some(false)
    else if y = Binop_Power    && x = Binop_Minus    then Some(false)
    else if y = Binop_Multiply && x = Binop_Plus     then Some(false)
    else if y = Binop_Multiply && x = Binop_Minus    then Some(false)
    else if isMisc y           && isBoolean x        then Some(false)
    else if isMisc y           && isComparision x    then Some(false)
    else if isComparision y    && isBoolean x        then Some(false)

    (* The following rules might be a mistake - though they do seem
     * to match common usage.
     *)
    else if x = Binop_Minus    && y = Binop_Plus     then Some(true)
    else if x = Binop_Minus    && y = Binop_Minus    then Some(true)

    else None

(** Parsing exceptions (2/2) *)
exception PrecedenceError of l * binop * binop

(* Support function for parsing expression trees of the form
 *
 *     ... op x op_1 y_1 op_2 y_2 ... op_n y_n
 *
 * Consumes input until it finds an operator y_i of lower precedence
 * than op returning
 *
 * 1) an expression representing "x op_1 ... y_i-1"
 * 2) the remainder if the input "op_i y_i ... op_n y_n"
 *
 * As in Dijkstra's "Shunting Yard" algorithm, we work left to right across
 * the expression comparing the next two operators:
 * - op1 > op2 => (x op1 y1) op2 ...
 * - op1 < op2 => x op1 (y1 op2 ...) ...
 * - op1 = op2 => (x op1 y1) op2 ...     if op1 is associative
 * - _         => error
 *)
let rec buildExpr (op: binop) (x: expr) (ys: factor list) (loc: l): (expr * factor list) =
    ( match ys with
    | [] ->
        (x, [])
    | (Factor_BinOp(op1, y1) :: ys1) ->
        ( match higherPriorityThan op op1 with
        | Some(false) ->
            ( match ys1 with
            | (Factor_BinOp(op2, _) :: _) ->
                ( match higherPriorityThan op1 op2 with
                | Some(true) ->
                    buildExpr op (Expr_Binop(x, op1, y1)) ys1 loc
                | Some(false) ->
                    let (r, rs) = buildExpr op1 y1 ys1 loc in
                    buildExpr op (Expr_Binop(x, op1, r)) rs loc
                | None ->
                    if op1 = op2 && isAssociative(op1) then
                        buildExpr op (Expr_Binop(x, op1, y1)) ys1 loc
                    else
                        raise (PrecedenceError(loc, op1, op2))
                )
            | [] ->
                (Expr_Binop(x, op1, y1), [])
            )
        | _ -> (x, ys)
        )
    )

(* Construct an expression tree based on precedence rules
 *
 * Given parser output of the form  x op_1 y_1 op_2 y_2 ...op_n y_n,
 * construct a tree based on the relative priorities of op1, ... opn.
 * If any adjacent operators op_i, op_i+1 are unordered, report
 * a parsing ambiguity.
 *
 * We use a recursive variant on Dijkstra's Shunting Yard algorithm to
 * parse a list of operator-expression pairs into an expression tree
 * based on operator precedences
 * All operators are treated as left-associative
 *)

let buildExpression (x: expr) (fs: factor list) (loc: l): expr =
    ( match buildExpr Binop_DUMMY x fs loc with
    | (e, []) -> e
    | (_, _) -> raise (Parse_error_locn(loc, "Impossible: unable to resolve precedence"))
    )
}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% End
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
